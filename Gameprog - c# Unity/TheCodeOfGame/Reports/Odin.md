# Odin Aas

## Grading rubric
Gameplay video: 15 points

[Code video](https://youtu.be/axdtx_yTr3M): 5

good code: 20

Bad code: 20

Development Process: 20

Reflection: 20

[Code video](https://youtu.be/axdtx_yTr3M) is linked here, also above in the rubric (its the same link, either one will work).

## Good code

I created a script that dynamically adds menu buttons based on what is currently within the build index (what scenes will be built). I am particularly proud of this piece of code, as this caused the concept of lambda functions to click in my head. (plus i found a weird "exeption" within c#)

It takes the scenecount in the build index, and goes through a foreach loop (important that its not a for loop) generating the button prefab, positioning it (parent object has automatic positioning and scaling). Then comes the "onclick" function. This stumped me for a while, as i was unsure how to create a function to call afterwards. I thought of creating a sort of callback with a lambda, but i quickly relized that variables were captured by refrence, and not by value. 



```c#
void Start()
{
    // remove one, as this is the count, not the indecies themselves
    int maxIndex = SceneManager.sceneCountInBuildSettings - 1;
    
    // starts at 1, as 0 index is the main menu
    foreach (int i in Enumerable.Range(1, maxIndex))
    {
        var button = Instantiate(ButtonPrefab, Vector3.zero, Quaternion.identity, ButtonRoot);
        button.name = "Level " + i.ToString();
        button.GetComponentInChildren<TextMeshProUGUI>().text = "Level " + i.ToString();

        button.GetComponent<Button>().onClick = new Button.ButtonClickedEvent();

        // create lambda that loads scene "i" NB: needs to be a foreach, NOT for
        button.GetComponent<Button>().onClick.AddListener(() => { SceneManager.LoadScene(i); });
    }
}
```
While researching a workaround i found out that values in C# are always captured by refrence, except within foreach loops specifically. Changing the loop to foreach fixed the problem and the buttons now work correctly, and by doing it this way, i saved myself the effort to create an entirely new script to handle the click events. 

## Bad code

I have done lots of work on the early iteration of the ball, and as i was not very proficient working with the unity engine, i made some mistakes.

First of all, i created a completley seperate "input action" (new input method), whereas most of the time (Except with multiplayer) you should only create one. And have one central (usually the player) gameobject controlling all of the controls.
This is because when a controller is plugged in, unity will automatically try to divide up the input action elements to each of the input controllers (ie keyboard, controller etc). This caused problems, and broke the game if there were multiple input controllers plugged in. Sadly there is no code i can show, that shows this problem, as it was purely autogenerated unity code.

My first idea to create the ball would be to create an interactor script, this script would look for interactable objects within a set radius, and call the "interact" function on this object. This was ultimatley more work than needed, as these interactor scripts are used when there is multiple different objects that can be interacted with. Thus this is bad for many reasons, such as described below. 
```c#
public interface Iinteracteble
{
    public string InteractionPrompt { get; }
    public bool Interact(Interactor interactor);
}

```

It calls "GetComponent" every frame something is within the radius (although most of the time its null) which is very bad for preformance. 
It also only checks the "zeroth" element, making it fail sometimes (what if two things were found?). (Luckily this code is deprecated and is no longer used) 
```c#
public class Interactor : MonoBehaviour
{
    [SerializeField] private Transform _interactionPoint;
    [SerializeField] private float _interactionPointRadius;
    [SerializeField] private LayerMask _interactableMask;

    private readonly Collider2D[] _colliders = new Collider2D[3];
    [SerializeField] private int _numFound;

    private void Update()
    {
        _numFound = Physics2D.OverlapCircleNonAlloc(_interactionPoint.position, _interactionPointRadius, _colliders, _interactableMask);

        if (_numFound > 0 )
        {
            var interactable = _colliders[0].GetComponent<Iinteracteble>();

            if (interactable != null && Keyboard.current.eKey.wasPressedThisFrame)
            {
                interactable.Interact(this);
            }
        }
    }
}
```
This was a very early version of the ball interaction, and is completley overhauled (multiple times) at the time of writing this. The code above is currently unused (but still in our files). 

The code itself isnt the main reason i have placed it within this section, with small tweaks this could be a good interaction system. What earns it the "bad code" label is that it solved a problem that didnt need to be solved. Picking up the ball is not really needed when you can magically transport into your hands.

Unfortunately i was sick at the third iteration of the ball and ended up not making the final version of the ball script. 

## Reflection

Now, i cannot really say i learned anything too specific from the course, but much was general "good-to-know" knowledge. This includes things such as how to efficiently work in a team, how to learn new concepts within programming (such as working with a large framwork like unity).

But this course also helped in understanding game programming and design better. And even though i dont agree with everything, such as that most players usually want an easy experience with their games. I strongly disagree that this is the main opinion among people who regularly play, but i do after the course understand that there are many that do like easy games. 

The course also taught me a good amound of general c# knowlege, i personally had very little experience with c# from beforehand. Now i know most of the basics (at least those that are useful in unity). Such as a statemachine, although i didnt write it, i had to learn what it was and how to use it. I added certain parts to the player statemachine, such as a limit to how many times you can throw the ball while in mid air. 

If i am going to create another game however, i would not use unity. It is by far the simplest engine to learn, but because of the simplicity, it somewhat takes away the programming aspect of the work. Instead of relying on programming knowledge, you have to learn more in-depth about one specific thing (that you might not use again). So therefore i would rather use godot, it has support for multiple languages, like C++, c#, GDscript and c. This would allow for a more in depth control of what the game does, and how the player interacts with the game. This isnt even mentioning what unity tried to do earlier this year, the "pay-per-download" "scheme" ruined all credibility of the engine. Even though it didnt pass through, it was still an attempt at something that would completley kill some games.

Going on to a different topic, here are some things i like, and dislike about what we have created:

#### Dislikes:

Some of the controls, while they are fluid when done slowly, are clunky when done fast (as is the purpose of the game). One instance of this which got a lot of hate from our friends and family testing, was the hold to aim, click to shoot mechanic. This is where you hold left click to start aiming, and then click right click, while holding left, to throw the ball (then click right click again to teleport). 

Most of our testers recomended us to change the controls to throw on *release* of the left mouse button. When i, very early in development implemented the ball throwing, this was how it worked, but on remaking the system entirely, this ended up being changed to what it now is.

#### Likes:

The concept of the game is really cool, and the endless possibilites for expansion is very cool. Some of the possible gameplay mechanics i'd like to add would be ball modifications (sticky ball sticks to walls, ball does not bounce etc), ares you cant teleport/throw the ball. And this is to me, the most important part of creating a game, enjoying what you create. 

# Conclusion

All in all, working on this game has been useful in a multitude of ways. I have become better at working together in a group, i have learnt how to learn (a framework), and i have learnt a whole bunch about how to use unity (and probably some other similar engines).